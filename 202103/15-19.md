#### 2021.03.15
---
加班

#### 2021.03.16
---
> vue组件继承
1. 继承-用法1
    * 被继承的对象相当于是Vue的一个子类，如例子中的compVue，compVue接受的props属性，实例要通过propsData属性把值传过去
    * 实例中的data会和类（compVue）中的data属性合并
    * mounted方法：会先调用类中的mounted,再调用实例的mounted
```
    import Vue from 'vue'

    const component = {
        props: {
            active: Boolean,
            propOne: String
        },
        template: `<div>
            <input type="text" v-model.number="text"/>
            <span @click="handleChange">{{propOne}}</span>
            <div v-show="active">see me if active</div>
            </div>`,
        data() {
            return {
            text: 0
            }

        },
        mounted() {
            console.log('comp computed')
        },
        methods: {
            handleChange(){
            this.$emit('change')
            }
        }
    }
    // 相当于是vue的子类
    const compVue = Vue.extend(component)
    // 实例
    new CompVue({
        el:'#root',
        propsData: {
            propOne: 'xxx'
        },
        data(){
            return {
                text: 123,
                test: 456
            }
        },
        mounted() {
            console.log('instance computed')
        }
    })
```
2. 继承-用法2
    * mounted也是先输出被继承的对象的，再输出继承的对象的
```
    import Vue from 'vue'

    const component = {
        props: {
            active: Boolean,
            propOne: String
        },
        template: `<div>
            <input type="text" v-model.number="text"/>
            <span @click="handleChange">{{propOne}}</span>
            <div v-show="active">see me if active</div>
            </div>`,
        data() {
            return {
            text: 0
            }

        },
        mounted() {
            console.log('comp computed') // 1
        },
        methods: {
            handleChange(){
            this.$emit('change')
            }
        }
    }
    const comp2 = {
        extends: component,
        data() {
            return {
            text: 1
            }
        },
        mounted() {
            console.log('comp2 mounted') // 2
        }
    }
    new Vue({
        el: 'root',
        components: {
            comp: comp2
        },
        template: `<comp></comp>`
    })
```
> $parent
组件comp2的父组件就是new Vue时生成的实例
子组件可以修改父组件的数据，但是尽量不要去修改，因为时间一长就忘记了，看着就有点晕乎
vue组件的父组件一般是改不了的，在渲染的时候就已经确定了
```
    import Vue from 'vue'

    const component = {
        props: {
            active: Boolean,
            propOne: String
        },
        template: `<div>
                <input type="text" v-model.number="text"/>
                <span @click="handleChange">{{propOne}}</span>
                <div v-show="active">see me if active</div>
            </div>`,
        data() {
            return {
                text: 0
            }

        },
        mounted() {
            console.log('comp computed') // 1
        },
        methods: {
            handleChange(){
                this.$emit('change')
            }
        }
    }
    const parent = new Vue({
        name: 'parent'
    })
    const comp2 = {
        parent,
        extends: component,
        data() {
            return {
                text: 1
            }
        },
        mounted() {
            console.log(this.$parent.$options.name)  // Root
            this.$parent.text = 123456
        }
    }
    new Vue({
        parent,
        el: 'root',
        name: 'Root'
        components: {
            comp: comp2
        },
        mounted() {
            console.log(this.$parent.$options.name)  // parent
        },
        data() {
            return {
                text: 2
            }
        },
        template: `
            <div>
                <span>{{text}}</span>
                <comp></comp>
            </div>
        `
    })
```

#### 2021.03.17
---
> v-model双向绑定
1. 实现
v-model相当于是输入的时候，子组件触发了input方法，子组件通知父组件值有所改变，父组件接到通知后，对值进行修改，再把值传给子组件的value,输入框再绑定value,这样就实现了v-model
```
    import Vue from 'vue'

    const component = {
        props: ['value'],
        template: `
            <div>
            <input type="text" @input="handleInput" :value="value">
            </div>
        `,
        methods: {
            handleInput(e) {
                this.$emit('input', e.target.value)
            }
        }
    }

    new Vue({
        el: '#root',
        components: {
            CompOne: component
        },
        data() {
            return {
            value1: ''
            }
        },
        // v-model的内部实现：<comp-one :value="value1" @input="value1 = arguments[0]"></comp-one>
        template: `
            <div>
                <comp-one v-model="value1"></comp-one>
            </div>
        `
    })
```
2. 也可以修改v-model的参数，默认是传value值，监听input事件
```
    import Vue from 'vue'

    const component = {
        model: {
            prop: 'value1',
            event: 'haha'
        },
        props: ['value1'],
        template: `
            <div>
                <input type="text" @input="handleInput" :value="value1">
            </div>
        `,
        methods: {
            handleInput(e) {
                this.$emit('haha', e.target.value) // 改变的时候通知父组件
            }
        }
    }

    new Vue({
        el: '#root',
        components: {
            CompOne: component
        },
        data() {
            return {
            value1: ''
            }
        },
        // <comp-one :value="value1" @input="value1 = arguments[0]"></comp-one>
        // <comp-one v-model="value1"></comp-one>
        template: `
            <div>
                <comp-one v-model="value1"></comp-one>
            </div>
        `,
        methods: {

        }
    })

```

#### 2021.03.08
---
> Vue高级属性
1. slot
插槽: 其中一些固定的不变的，如样式，例如弹框，里面的内容会改变，外观不会变，就可以使用插槽(本质就是用父组件的内容替换子组件内对应的slot部分)
    > 子组件中定义了插槽，父组件中引入子组件，就可以定义要显示的内容了；有时会有多个内容，要显示在不同的插槽内，所以出现了具名插槽，即给子组件的slot上设置name属性，父组件在模板中的子组件内部的现实内容上增加slot属性
    ```
        import Vue from 'vue'
        const component = {
            name: 'comp',
            template: `<div :style="style">
                <div class="header">
                    <slot name="header"></slot>
                    
                </div>
            </div>`,
            data() {
                return {
                    style: {
                        width: '200px',
                        height: '200px',
                        border: '1px solid #aaa'
                    },
                    value: 'component value'
                }
            }
        }

        const hahah = new Vue({
            el: '#root',
            components: {
                CompOne: component
            },
            data() {
                return {
                    value: 123
                }
            },
            template:  `
                <div>
                    <comp-one ref="comp">
                        <span ref="span" slot="header" slot-scope="props">{{props.value}}-{{props.aaa}}-{{value}}</span>
                        <span>456</span>
                    </comp-one>
                </div>
            `
            })
    ```
    > 作用域插槽: 父组件要显示子组件的数据，可以使用在子组件中传值，父组件中用`slot-scope`接收，接收到的是一个对象，对象中的key值对应子组件传入的key,如例子中的value
    ```
        import Vue from 'vue'
        const component = {
            name: 'comp',
            template: `<div :style="style">
                <div class="header">
                    <slot name="header" :value="value"
                    :aaa="aaa"
                    ></slot>
                    
                </div>
            </div>`,
            data() {
                return {
                    style: {
                        width: '200px',
                        height: '200px',
                        border: '1px solid #aaa'
                    },
                    value: 'component value',
                    aaa: 'jaha'
                }
            }
        }

        const hahah = new Vue({
            el: '#root',
            components: {
                CompOne: component
            },
            data() {
                return {
                    value: 123
                }
            },
            template:  `
                <div>
                    <comp-one ref="comp">
                        <span ref="span" slot="header" slot-scope="props">{{props.value}}-{{props.aaa}}-{{value}}</span>
                        <span>456</span>
                    </comp-one>
                </div>
            `
            })
    ```
2. ref：可以在组件中加入ref属性，可以通过`this.$refs.refName`来操作vue实例中的属性和方法；也可以在html标签上加上ref属性，`this.$refs.refName`会返回dom节点
    
    * 组件中加入ref属性，可以操作属性可方法，但是一般不要这么操作属性和方法（可以利用Props），不利于团队协作，不利于别人阅读，可以用，不要滥用

3. provide: 在跨层级的上下文关系里(不是父子组件关系)，要实现组件的沟通时即可使用,provide不支持vue的reactive属性，需要的话可以改造下：例如可以通过provide传入时设置get属性
```
    import Vue from 'vue'

    const ChildComponent = {
        template: `<div>child component {{data.value}}</div>`,
        inject: ['yeye', 'data'],  // 注入
        mounted() {
            console.log('yeye', this.yeye)
            console.log('value', this.data.value)
        }
    }

    const component = {
        name: 'comp',
        components: {
            ChildComponent
        },
        template: `<div :style="style">
            <div class="header">
                <slot name="header" :value="value" aaa="1111"></slot>
                <child-component/>
            </div>
        </div>`,
        data() {
            return {
            style: {
                width: '200px',
                height: '200px',
                border: '1px solid #aaa'
            },
            value: 'component value'
            }
        }
    }

    const hahah = new Vue({
        el: '#root',
        components: {
            CompOne: component
        },
        provide() {
            const data = {}
            Object.defineProperty(data, 'value', {
                get: ()=> this.value,
                enumerable: true
            })
            return {
                yeye: this,
                data
            }
        },
        data() {
            return {
                value: 123
            }
        },
        mounted() {
            // console.log(this.$refs.comp.value)
            // console.log(this.$refs.span)
        },
        template:  `
            <div>
                <comp-one ref="comp">
                    <span ref="span" slot="header" slot-scope="props">{{props.value}}-{{props.aaa}}-{{value}}</span>
                    <span>456</span>
                </comp-one>
                <input type="text" v-model="value"/>
            </div>
        `
        })
```